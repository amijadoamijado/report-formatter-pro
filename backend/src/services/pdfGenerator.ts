import fs from 'fs-extra';
import path from 'path';
import puppeteer from 'puppeteer';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export interface PdfGenerationOptions {
  title?: string;
  author?: string;
  subject?: string;
  keywords?: string[];
  includeExecutiveSummary?: boolean;
}

export interface PdfResult {
  success: boolean;
  pdfPath?: string;
  pdfBuffer?: Buffer;
  error?: string;
  metadata?: {
    pageCount: number;
    fileSize: number;
    generatedAt: string;
  };
}

export class ProfessionalPdfGenerator {
  private stylesPath: string;
  private outputDir: string;

  constructor() {
    this.stylesPath = path.join(__dirname, '..', '..', '..', 'styles');
    this.outputDir = path.join(__dirname, '..', '..', 'generated');
    this.ensureDirectories();
  }

  /**
   * å¿…è¦ãªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆ
   */
  private async ensureDirectories(): Promise<void> {
    await fs.ensureDir(this.outputDir);
  }

  /**
   * ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ—ãƒ­ãƒ•ã‚§ãƒƒã‚·ãƒ§ãƒŠãƒ«ãªHTMLã«å¤‰æ›
   */
  private async convertTextToHtml(
    text: string, 
    originalFilename: string, 
    options: PdfGenerationOptions = {}
  ): Promise<string> {
    
    // CSSãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
    const cssContent = await fs.readFile(
      path.join(this.stylesPath, 'professional-layout.css'), 
      'utf-8'
    );

    // ãƒ†ã‚­ã‚¹ãƒˆã‚’æ®µè½ã«åˆ†å‰²
    const paragraphs = text.split(/\n\s*\n/).filter(p => p.trim());
    
    // HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆ
    let htmlContent = '';
    
    // ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰ç”Ÿæˆï¼‰
    const title = options.title || this.generateTitleFromFilename(originalFilename);
    htmlContent += `<h1 class="main-title">${this.escapeHtml(title)}</h1>\n\n`;
    
    // Executive Summaryï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
    if (options.includeExecutiveSummary && paragraphs.length > 0) {
      htmlContent += `
<div class="executive-summary">
  <div class="title">Executive Summary</div>
  <div class="content">${this.escapeHtml(paragraphs[0])}</div>
</div>
\n`;
      paragraphs.shift(); // æœ€åˆã®æ®µè½ã‚’Executive Summaryã¨ã—ã¦ä½¿ç”¨æ¸ˆã¿
    }
    
    // æœ¬æ–‡ã®å‡¦ç†
    for (let i = 0; i < paragraphs.length; i++) {
      const paragraph = paragraphs[i].trim();
      
      if (this.isHeading(paragraph)) {
        const level = this.getHeadingLevel(paragraph);
        const cleanHeading = this.cleanHeading(paragraph);
        
        if (level === 1) {
          htmlContent += `<h2 class="section-header">${this.escapeHtml(cleanHeading)}</h2>\n`;
        } else if (level === 2) {
          htmlContent += `<h3 class="subsection-header">${this.escapeHtml(cleanHeading)}</h3>\n`;
        }
      } else if (this.isBulletList(paragraph)) {
        htmlContent += this.convertToBulletList(paragraph);
      } else if (this.isNumberedList(paragraph)) {
        htmlContent += this.convertToNumberedList(paragraph);
      } else {
        // é€šå¸¸ã®æ®µè½
        const processedParagraph = this.processTextFormatting(paragraph);
        htmlContent += `<p class="body-text">${processedParagraph}</p>\n`;
      }
      
      htmlContent += '\n';
    }

    // å®Œå…¨ãªHTMLãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆç”Ÿæˆ
    return `
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${this.escapeHtml(title)}</title>
    <style>
${cssContent}
    </style>
</head>
<body>
${htmlContent}
    <div class="document-footer">
        Generated by ReportFormatter Pro | ${new Date().toLocaleDateString('ja-JP')}
    </div>
</body>
</html>`;
  }

  /**
   * HTMLã‹ã‚‰PDFã‚’ç”Ÿæˆ
   */
  public async generatePdf(
    text: string,
    originalFilename: string,
    options: PdfGenerationOptions = {}
  ): Promise<PdfResult> {
    try {
      console.log('ğŸ“„ PDFç”Ÿæˆé–‹å§‹:', originalFilename);
      
      // HTMLã«å¤‰æ›
      const htmlContent = await this.convertTextToHtml(text, originalFilename, options);
      
      // Puppeteer ã§PDFç”Ÿæˆ
      const browser = await puppeteer.launch({
        headless: true,
        args: ['--no-sandbox', '--disable-setuid-sandbox']
      });
      
      const page = await browser.newPage();
      
      // HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’è¨­å®š
      await page.setContent(htmlContent, {
        waitUntil: 'networkidle0'
      });
      
      // PDFç”Ÿæˆè¨­å®š
      const pdfBuffer = await page.pdf({
        format: 'A4',
        margin: {
          top: '2.5cm',
          right: '2cm',
          bottom: '2.5cm',
          left: '2cm'
        },
        printBackground: true,
        preferCSSPageSize: true,
        displayHeaderFooter: false,
        scale: 1.0,
        quality: 100
      });
      
      await browser.close();
      
      // ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const filename = `${path.parse(originalFilename).name}_professional_${timestamp}.pdf`;
      const outputPath = path.join(this.outputDir, filename);
      
      await fs.writeFile(outputPath, pdfBuffer);
      
      console.log('âœ… PDFç”Ÿæˆå®Œäº†:', filename);
      
      return {
        success: true,
        pdfPath: outputPath,
        pdfBuffer,
        metadata: {
          pageCount: 1, // TODO: å®Ÿéš›ã®ãƒšãƒ¼ã‚¸æ•°ã‚’å–å¾—
          fileSize: pdfBuffer.length,
          generatedAt: new Date().toISOString()
        }
      };
      
    } catch (error) {
      console.error('âŒ PDFç”Ÿæˆã‚¨ãƒ©ãƒ¼:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'PDFç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ'
      };
    }
  }

  /**
   * ãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰ã‚¿ã‚¤ãƒˆãƒ«ã‚’ç”Ÿæˆ
   */
  private generateTitleFromFilename(filename: string): string {
    return path.parse(filename).name
      .replace(/[-_]/g, ' ')
      .replace(/\b\w/g, c => c.toUpperCase());
  }

  /**
   * HTMLã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
   */
  private escapeHtml(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  /**
   * è¦‹å‡ºã—ã‹ã©ã†ã‹åˆ¤å®š
   */
  private isHeading(text: string): boolean {
    return /^#{1,3}\s/.test(text) || /^[A-Za-z0-9\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF\s]+$/.test(text) && text.length < 100;
  }

  /**
   * è¦‹å‡ºã—ãƒ¬ãƒ™ãƒ«ã‚’å–å¾—
   */
  private getHeadingLevel(text: string): number {
    const match = text.match(/^(#{1,3})/);
    return match ? match[1].length : 1;
  }

  /**
   * è¦‹å‡ºã—ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
   */
  private cleanHeading(text: string): string {
    return text.replace(/^#+\s*/, '').trim();
  }

  /**
   * ãƒ–ãƒ¬ãƒƒãƒˆãƒªã‚¹ãƒˆã‹ã©ã†ã‹åˆ¤å®š
   */
  private isBulletList(text: string): boolean {
    return /^[\s]*[-â€¢*]\s/.test(text);
  }

  /**
   * ç•ªå·ä»˜ããƒªã‚¹ãƒˆã‹ã©ã†ã‹åˆ¤å®š
   */
  private isNumberedList(text: string): boolean {
    return /^[\s]*\d+\.\s/.test(text);
  }

  /**
   * ãƒ–ãƒ¬ãƒƒãƒˆãƒªã‚¹ãƒˆã«å¤‰æ›
   */
  private convertToBulletList(text: string): string {
    const items = text.split(/\n\s*[-â€¢*]\s/).filter(item => item.trim());
    const listItems = items.map(item => `  <li>${this.escapeHtml(item.trim())}</li>`).join('\n');
    return `<ul class="bullet-list">\n${listItems}\n</ul>\n`;
  }

  /**
   * ç•ªå·ä»˜ããƒªã‚¹ãƒˆã«å¤‰æ›
   */
  private convertToNumberedList(text: string): string {
    const items = text.split(/\n\s*\d+\.\s/).filter(item => item.trim());
    const listItems = items.map(item => `  <li>${this.escapeHtml(item.trim())}</li>`).join('\n');
    return `<ol class="numbered-list">\n${listItems}\n</ol>\n`;
  }

  /**
   * ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’å‡¦ç†
   */
  private processTextFormatting(text: string): string {
    return this.escapeHtml(text)
      // å¼·èª¿è¡¨ç¤º
      .replace(/\*\*(.*?)\*\*/g, '<span class="emphasis">$1</span>')
      .replace(/\*(.*?)\*/g, '<em>$1</em>')
      // é‡è¦ãªéƒ¨åˆ†
      .replace(/\[é‡è¦\](.*?)\[\/é‡è¦\]/g, '<span class="critical">$1</span>')
      .replace(/\[å¼·èª¿\](.*?)\[\/å¼·èª¿\]/g, '<span class="highlight">$1</span>');
  }
}