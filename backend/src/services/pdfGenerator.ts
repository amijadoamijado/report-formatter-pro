import fs from 'fs-extra';
import path from 'path';
import puppeteer from 'puppeteer';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export interface PdfGenerationOptions {
  title?: string;
  author?: string;
  subject?: string;
  keywords?: string[];
  includeExecutiveSummary?: boolean;
}

export interface PdfResult {
  success: boolean;
  pdfPath?: string;
  pdfBuffer?: Buffer;
  error?: string;
  metadata?: {
    pageCount: number;
    fileSize: number;
    generatedAt: string;
  };
}

export class ProfessionalPdfGenerator {
  private stylesPath: string;
  private outputDir: string;

  constructor() {
    this.stylesPath = path.join(__dirname, '..', '..', '..', 'styles');
    this.outputDir = path.join(__dirname, '..', '..', 'generated');
    this.ensureDirectories();
  }

  /**
   * 必要なディレクトリを作成
   */
  private async ensureDirectories(): Promise<void> {
    await fs.ensureDir(this.outputDir);
  }

  /**
   * テキストをプロフェッショナルなHTMLに変換
   */
  private async convertTextToHtml(
    text: string, 
    originalFilename: string, 
    options: PdfGenerationOptions = {}
  ): Promise<string> {
    
    // CSSファイルを読み込み
    const cssContent = await fs.readFile(
      path.join(this.stylesPath, 'professional-layout.css'), 
      'utf-8'
    );

    // テキストを段落に分割
    const paragraphs = text.split(/\n\s*\n/).filter(p => p.trim());
    
    // HTMLコンテンツ生成
    let htmlContent = '';
    
    // タイトル（ファイル名から生成）
    const title = options.title || this.generateTitleFromFilename(originalFilename);
    htmlContent += `<h1 class="main-title">${this.escapeHtml(title)}</h1>\n\n`;
    
    // Executive Summary（オプション）
    if (options.includeExecutiveSummary && paragraphs.length > 0) {
      htmlContent += `
<div class="executive-summary">
  <div class="title">Executive Summary</div>
  <div class="content">${this.escapeHtml(paragraphs[0])}</div>
</div>
\n`;
      paragraphs.shift(); // 最初の段落をExecutive Summaryとして使用済み
    }
    
    // 本文の処理
    for (let i = 0; i < paragraphs.length; i++) {
      const paragraph = paragraphs[i].trim();
      
      if (this.isHeading(paragraph)) {
        const level = this.getHeadingLevel(paragraph);
        const cleanHeading = this.cleanHeading(paragraph);
        
        if (level === 1) {
          htmlContent += `<h2 class="section-header">${this.escapeHtml(cleanHeading)}</h2>\n`;
        } else if (level === 2) {
          htmlContent += `<h3 class="subsection-header">${this.escapeHtml(cleanHeading)}</h3>\n`;
        }
      } else if (this.isBulletList(paragraph)) {
        htmlContent += this.convertToBulletList(paragraph);
      } else if (this.isNumberedList(paragraph)) {
        htmlContent += this.convertToNumberedList(paragraph);
      } else {
        // 通常の段落
        const processedParagraph = this.processTextFormatting(paragraph);
        htmlContent += `<p class="body-text">${processedParagraph}</p>\n`;
      }
      
      htmlContent += '\n';
    }

    // 完全なHTMLドキュメント生成
    return `
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${this.escapeHtml(title)}</title>
    <style>
${cssContent}
    </style>
</head>
<body>
${htmlContent}
    <div class="document-footer">
        Generated by ReportFormatter Pro | ${new Date().toLocaleDateString('ja-JP')}
    </div>
</body>
</html>`;
  }

  /**
   * HTMLからPDFを生成
   */
  public async generatePdf(
    text: string,
    originalFilename: string,
    options: PdfGenerationOptions = {}
  ): Promise<PdfResult> {
    try {
      console.log('📄 PDF生成開始:', originalFilename);
      
      // HTMLに変換
      const htmlContent = await this.convertTextToHtml(text, originalFilename, options);
      
      // Puppeteer でPDF生成
      const browser = await puppeteer.launch({
        headless: true,
        args: ['--no-sandbox', '--disable-setuid-sandbox']
      });
      
      const page = await browser.newPage();
      
      // HTMLコンテンツを設定
      await page.setContent(htmlContent, {
        waitUntil: 'networkidle0'
      });
      
      // PDF生成設定
      const pdfBuffer = await page.pdf({
        format: 'A4',
        margin: {
          top: '2.5cm',
          right: '2cm',
          bottom: '2.5cm',
          left: '2cm'
        },
        printBackground: true,
        preferCSSPageSize: true,
        displayHeaderFooter: false,
        scale: 1.0,
        quality: 100
      });
      
      await browser.close();
      
      // ファイル保存
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const filename = `${path.parse(originalFilename).name}_professional_${timestamp}.pdf`;
      const outputPath = path.join(this.outputDir, filename);
      
      await fs.writeFile(outputPath, pdfBuffer);
      
      console.log('✅ PDF生成完了:', filename);
      
      return {
        success: true,
        pdfPath: outputPath,
        pdfBuffer,
        metadata: {
          pageCount: 1, // TODO: 実際のページ数を取得
          fileSize: pdfBuffer.length,
          generatedAt: new Date().toISOString()
        }
      };
      
    } catch (error) {
      console.error('❌ PDF生成エラー:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'PDF生成に失敗しました'
      };
    }
  }

  /**
   * ファイル名からタイトルを生成
   */
  private generateTitleFromFilename(filename: string): string {
    return path.parse(filename).name
      .replace(/[-_]/g, ' ')
      .replace(/\b\w/g, c => c.toUpperCase());
  }

  /**
   * HTMLエスケープ
   */
  private escapeHtml(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  /**
   * 見出しかどうか判定
   */
  private isHeading(text: string): boolean {
    return /^#{1,3}\s/.test(text) || /^[A-Za-z0-9\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF\s]+$/.test(text) && text.length < 100;
  }

  /**
   * 見出しレベルを取得
   */
  private getHeadingLevel(text: string): number {
    const match = text.match(/^(#{1,3})/);
    return match ? match[1].length : 1;
  }

  /**
   * 見出しをクリーンアップ
   */
  private cleanHeading(text: string): string {
    return text.replace(/^#+\s*/, '').trim();
  }

  /**
   * ブレットリストかどうか判定
   */
  private isBulletList(text: string): boolean {
    return /^[\s]*[-•*]\s/.test(text);
  }

  /**
   * 番号付きリストかどうか判定
   */
  private isNumberedList(text: string): boolean {
    return /^[\s]*\d+\.\s/.test(text);
  }

  /**
   * ブレットリストに変換
   */
  private convertToBulletList(text: string): string {
    const items = text.split(/\n\s*[-•*]\s/).filter(item => item.trim());
    const listItems = items.map(item => `  <li>${this.escapeHtml(item.trim())}</li>`).join('\n');
    return `<ul class="bullet-list">\n${listItems}\n</ul>\n`;
  }

  /**
   * 番号付きリストに変換
   */
  private convertToNumberedList(text: string): string {
    const items = text.split(/\n\s*\d+\.\s/).filter(item => item.trim());
    const listItems = items.map(item => `  <li>${this.escapeHtml(item.trim())}</li>`).join('\n');
    return `<ol class="numbered-list">\n${listItems}\n</ol>\n`;
  }

  /**
   * テキストフォーマットを処理
   */
  private processTextFormatting(text: string): string {
    return this.escapeHtml(text)
      // 強調表示
      .replace(/\*\*(.*?)\*\*/g, '<span class="emphasis">$1</span>')
      .replace(/\*(.*?)\*/g, '<em>$1</em>')
      // 重要な部分
      .replace(/\[重要\](.*?)\[\/重要\]/g, '<span class="critical">$1</span>')
      .replace(/\[強調\](.*?)\[\/強調\]/g, '<span class="highlight">$1</span>');
  }
}